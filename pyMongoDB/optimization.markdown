# Optimization Strategies for MongoDB

<br>
<br>

该条目施工中, 参考文档: http://docs.mongodb.org/manual/administration/optimization/

#### Read vs. Write

对于应用的优化, 首先必须对读写性能进行测试以便找到性能瓶颈.
对读操作的优化通常包括正确使用索引, 以及尽可能将有效信息放在单个文档中.
对写操作的优化通常包括减少索引数量以及尽可能提高更新效率.
对于读写操作的权衡, 不只是要求读更快还是写更快, 也要考虑是读多还是写多.

#### Document Growth

更新数据时, 需要明确更新是否会导致文件体积增长以及它的增长速度.
如果增长程度是可以预知的就可以为文档预留足够的增长空间,
这样就可以避免产生碎片以提高写入速度.

对于一些具有时效性的数据, 通常可以使用固定集合或者 TTL 集合来移除那些已经过期的数据.
在一些场景中, 按照一定的规则来使用多个集合组织数据也是一个行之有效的方法.

#### Optimal Design

除了文档的结构外, 数据库和集合结构的设计也对性能有着重要的影响.

通常来说, 具有相似结构的文档应该存储在一个集合内.
但是 MongoDB 通常不允许使用多个集合组合数据, 所以还存在一个更高的优先级,
如果有些文档需要进行集中查询或者聚合操作, 那么这些文档就应该是存在于同一集合内的
(即使这些文档的结构可能一点也不相似).

对于数据库来说, 最大的问题是锁机制和存储.
每一个数据库在磁盘上都有自己独立的文件, 这就意味着可以让不同的数据库位于不同的磁盘分卷.
所以, 你可能希望数据库内的所有项目都拥有相近的 "质量", 相近的访问模式甚至相近的访问量.

假设对于一个多组件的应用程序, 它包括一个用户集合, 若干个用户产生数据的集合以及一个日志集合.
首先我们就明确, 用户集合是最重要的, 其次就是用户产生数据的集合, 最后是日志集合.
于是就可以按照重要性来组织三个数据库: `users`, `activities`, `logs`.
这样做的好处是, 首先用户数据库的数据量可能是最小的,
它可以存储在固态硬盘上以提高读写效率, 而其它数据可以存储在机械硬盘上降低成本.
或者是对于用户数据库可以使用 RAID10 而其它数据使用 RAID0.

#### Version

对于应用经常变更需求导致数据库字段不统一的情况, 一个最直接有效的解决方案就是使用 `version` 字段.
可以通过版本控制来限制应用可以访问的文档, 这样来应对由于版本迭代产生的字段缺失或变更问题.
在设计应用的开始阶段就应该严格设计合理的数据模型以应对需求的变化.
