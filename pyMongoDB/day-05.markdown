# MongoDB Day 5

<br>
<br>

## Advanced Usage

#### $ 操作符如何使用索引

在 MongoDB 定义的众多操作符中, 有一些查询完全无法使用索引, 比如 `$where`, `$exists`, etc.
也有一些操作符可以使用索引但是并不效率, 比如 `$ne`, `$not`, etc.

如果需要快速执行一个这些类型的查询, 可以试着找到另一个能够使用索引的语句并将其添加到查询中.
这样就可以在 MongoDB 进行 "non-indexed matching" 时先将结果集的文档数量减到一个比较小的水平.

例如我们要找到所有没有 `author` 字段的书籍, 且明确知道数据库从一个固定日期开始才加入的该字段.

```js
db.books.find({"author": {"$exists": false}, "_id": {"$lt": march20Id}})
```

在这个查询中, 字段的顺序无关紧要, MongoDB 会自动找出可以使用索引的字段.

#### 范围查询中使用索引

在设计复合索引时, 应该将会用于精确匹配的字段放在索引的前面, 将用于范围匹配的字段放在最后.

```js
db.collection.find({"x": "foo", "y": {"$gt": 3, "$lt": 5}})
```

如上例, 查询可以先使用第一个索引键进行精确匹配, 然后再使用第二个索引范围在整个结果集内搜索.


#### 多索引查询

```js
db.books.ensureIndex({"author": 1})
db.books.ensureIndex({"date": 1})

db.books.find({"author": "chus", "date": {"$lt": "20141218"}}).explain()
```

MongoDB 在一次查询中只使用一个索引, 因此在上例的查询中, 只有 `{"author": 1}` 产生作用.
对此存在一个变通方法就是使用 `$or` 操作符, 它可以允许对每个条件都使用索引 (如果存在索引),
因为使用 `$or` 实际上是分别对每个索引执行了查询然后返回合并后的结果集.

```js
db.books.find({"$or": [{"author": "chus"}, {"date": {"$lt": "20141218"}}]}).explain()
```

执行上边的查询, 可以看到 `explain()` 的输出会有两次独立的查询组成.
通常来说, 执行多次查询再将结果合并的效率绝对不会比单次查询高,
因此更多时候还是使用 `$in` 而不是使用 `$or` 查询.
此外需要注意的是 `$in` 不能控制返回结果的顺序, 需要额外进行排序.

#### 索引对象和数组

MongoDB 允许深入文档内部对嵌套字段和数组建立索引.
嵌套对象和数组字段可以与复合索引中的顶级字段一起使用.

```js
/*
## db.users ##

{
    "username": "sid",
    "location": {
        "ip": "1.2.3.4",
        "city": "Springfield",
        "state": "NY"
    }
}
*/

// 对上面的嵌套文档中的 'city' 字段建立索引
db.users.ensureIndex({"location.city": 1})
// 该索引就会优化类似于下面的查询
db.users.find({"location.city": "Springfield"})
```

对数组建立索引从语法上和嵌套文档没什么不同.
假设有一个 `blog` 集合, 其中每个文档表示一篇文章, 每篇文章都有一个 `comments` 字段,
该字段是一个数组, 其中每个元素 (嵌套子文档) 表示一条评论,
现根据评论的时间建立索引:

```js
db.blog.ensureIndex({"comments.date": 1})
```

对数组建立的索引, 实际上是对数组中每个元素建立一个索引条目.
所以如果一篇文章有 20 条评论, 那么它就拥有 20 个索引条目.
因此数组索引的代价比单值索引要高的多, 对于单次写操作, 每一个数组条目可能都需要更新.
此外, 少数特殊情况下可以对数组中的特定元素建立索引.

一个索引中的数组字段最多只能有一个, 这是为了避免在复合索引中索引条目爆炸性增长.

```js

db.mult.ensureIndex({"x": 1, "y": 1})
// x 或 y 任意一个为数组都是合法的
db.mult.insert({"x": [1, 2, 3], "y": 1})
db.mult.insert({"x": 1, "y": [4, 5, 6]})
// x 与 y 同为数组则不合法
db.mult.insert({"x": [1, 2, 3], "y": [4, 5, 6]})
/*
因为每一对可能的元素都要被索引, 这样就导致如果 `x` 与 `y` 同为数组时要创建 9 个索引,
尽管这两个数组分别只有 3 个元素.

{"x": 1, "y": 4}, {"x": 1, "y": 5}, {"x": 1, "y": 6},
{"x": 2, "y": 4}, ...
{"x": 3, "y": 4}, ...
*/
```

#### 关于多键索引的注意事项

对于某个索引的键, 如果这个键在某个文档中是一个数组,
那么这个索引就会被标记为 'multikey index' (使用 `explain()` 查看 `isMultikey: true`).
一旦一个索引被标记为多键索引它就无法再变成非多键索引了,
即使该字段为数组的所有文档都从集合中删除也不会改变多键索引.
要将多键索引变为非多键索引的唯一方法就是删除这个索引再将它重新建立在不存在数组的键上.
多键索引会比非多键索引效率低一些, 因为可能会有多个索引条目指向同一个文档,
因此 MongoDB 在返回结果时需要先去除重复的内容.

#### Cardinality

Cardinality 指的是集合中某个键拥有不同值的数量.
比如 `datetime` 这样的字段, 就可能在每个文档中的值都不一样, 这类键就拥有非常高的基数.
而比如使用 boolean 值的键就肯定拥有较低的基数.

通常, 一个键的基数越高, 这个键上的索引就越能发挥作用.
这是因为索引能够迅速将搜索范围缩小到一个较小的结果集.
而对于低基数的字段索引通常就无法排除掉大量可能的匹配.

所以一般索引都会在基数比较高的键上建立, 或者在复合索引中将基数较高的键放在基数较低的键之前.
