# MongoDB Day 12

<br>
<br>

## Replica set Mechanism

#### Sync

MongoDB 的 replica 是使用操作日志 `oplog` 实现的, 它包含了 primary 的每一次写操作.
`oplog` 是主节点的 `local` 数据库中的一个固定集合. 备份节点通过查询这个集合就可以知道需要复制的操作.
每个备份节点都在维护自己的 `oplog`, 这样每个成员都可以作为同步源提供给其它节点同步.

#### initial sync

副本集启动后, 某一节点从其它节点进行完整的数据同步的过程称为 "initial syncing".

1. prepare: 选择一个节点作为同步源, 在 `local.me` 中为自己创建一个标识符并删除当前所有数据库.
2. clone: 将同步源的所有记录完整复制到本地.
3. re-clone: 同步过程中的所有操作都被记录到 `oplog`, 如果在同步过程中有新的变更被记录, 则重新同步变更内容.
4. record: 记录第一次 clone 过程中的操作
5. index: 到目前为止, 本地数据应该与主节点在某一个时间点上一致了, 之后会创建开始索引.
6. re-clone: 如果当前节点数据仍远落后于同步源, 那么最后还会再进行一次同步.

Clone 可能会损坏同步源的 working set, 实际部署后可能会有一个频繁使用的数据子集常驻内存.
执行初始化同步时会强制将当前成员的所有数据分页加载到内存中, 这会导致需要频繁访问的数据不能常驻内存,
因而导致请求处理速度变慢, 因为原本只要在内存中就可以处理的数据要先从磁盘上加载.

此外初始化同步过程还可能会出现由于 clone 或 build indexes 的耗时过久而导致新节点和同步源的 `oplog` "脱节".
新节点远远落后于同步源, 导致新节点的数据同步速度赶不上同步源的数据变化速度,
而同步源就可能会将新节点需要复制的某些数据覆盖. 这个问题暂时没有有效的解决方法,
除非是人为控制在闲时进行初始化同步, 或者是从备份中恢复数据.

#### stale data

如果备份节点远远落后于同步源当前的操作, 该备份节点就被称为陈旧的 (stale).
当一个节点变为陈旧状态, 它就会查看副本集中其它成员, 如果某个成员的 `oplog` 足够详尽,
可以用于处理那些遗失的操作, 那么就以该节点作为同步源进行同步. 而如果所有成员都不满足这个条件,
则该陈旧节点就会执行初始化同步.

为了避免出现陈旧节点, 应该为主节点设定比较大的 `oplog` 以保存足够多的操作.
MongoDB 自动创建的 `oplog` 最大不会超过 `50 GB`, 可以使用 `oplogSizeMB` 或 `--oplogSize` 设定更大的值.
通常对于 64-bit 系统来说 `oplog` 的大小为磁盘的 `5%` 较为合适.

#### heartbeat

一个副本集通过 heartbeat 来保证集群的一致性,
副本集中的所有成员会每 2 秒发送一次 heartbeat request 来检查其它成员的状态.
副本集中的成员通常包含以下几种状态:
- `STARTUP` - 成员刚启动时的状态. 成员处于这个状态时 MongoDB 会尝试加载成员的副本集配置,
配置加载成功之后就进入 `STARTUP2` 状态.
- `STARTUP2` - 整个初始化同步过程都处于这个状态, 但是如果在普通成员上, 这个状态只会持续几秒.
在这个状态下, MongoDB 会创建几个线程用于处理同步和选举, 然后进入 `RECOVERING` 状态.
- `RECOVERING` - 成员处于数据再生状态时已经在进行同步但还没有 "consistent view",
在处理非常耗时的操作时或一个成员与它的同步源脱节时都会进入这个状态, 此时成员不可用, 且可能会有轻微的系统过载现象.
- `PRIMARY` - 表示该节点是当前的主节点.
- `SECONDARY` - 表示该节点是一个次要节点, 值得注意的是陈旧节点也会暂时处于这个状态.
- `ARBITER` - 当仲裁者正常运行时就处于该状态.
- `UNKNOWN` - 如果一个成员无法连通其它成员, 就会处于该状态. 这通常表明一个成员意外离线了.
- `DOWN` - 如果一个正常运行的成员变得不可达, 它就处于 `DOWN` 状态.
- `REMOVED` - 当成员被移出副本集时, 它就处于这个状态. 当它重新被添加到副本集后就回到正常状态.
- `ROLLBACK` - 表示成员正在进行数据回滚, 该状态下数据不可用, 回滚结束后进入 `RECOVERING` 状态.
- `FATAL` - 当一个成员发生了不可挽回的错误, 也不再进行恢复尝试的情况下, 它就处于这个状态.
应该通过关键词 "replSet FATAL" 在日志中进行问题定位寻找解决方法.

#### election

当一个成员无法到达主节点时, 它就会申请被选举为主节点. 希望被选举为主节点的成员会向它能到达的所有成员发送通知.
如果这个成员符合候选人要求, 其它成员就会发起选举, 一旦该成员得到多数支持则会成为新的主节点.
主节点会一直处于 primary 状态, 除非它不再满足多数支持.

通常来说, 在副本集多数节点运行正常的情况下, 选举的过程是很快的. 如果主节点不可用,
则 2 秒内 (一个心跳周期内) 就会有成员发现主节点离线并立即发起并完成选举.
但实际情况下, 网络波动或者服务器过载等情况都可能触发选举, 无法完成心跳同步时心跳机制会在 20 秒后超时,
如果选举结果为平局, 则需要等待 30 秒发起下次选举. 所以, 有时选举也许会耗费几分钟的时间才能完成.

#### rollback

如果主节点执行了一个写操作后意外离线, 但是备份节点还没有复制主节点的本次操作,
那么新选举的主节点就会漏掉这次操作而继续接收之后的写操作.
一旦当原来的主节点解决故障重新加入这个副本集时, 它就会和新的主节点的 `oplog` 产生冲突.

当这种情况发生时, 出现冲突的节点就会进入 `ROLLBACK` 状态开始执行回滚.
此时服务器会比较彼此的 `oplog` 寻找一个相同的操作点,
然后将导致冲突的操作撤销并将这些操作记录到一个单独的 `BSON` 文件中.
该文件位于 `$dbpath/rollback/` 目录下, 以 `<database>.<collection>.<timestamp>.bson` 格式保存.
管理员可以通过 `bsondump` 来读取这些信息并进行修改, 然后使用 `monogrestore` 应用这些变更到新的主节点.
完成回滚后成员就会进入 `RECOVERING` 状态开始同步数据最终回到一个正常的 `SECONDARY`.

回滚是用来解决一些小的同步问题, 一旦数据量超过 `300 MB` 或者要回滚 `30 mins` 以上的操作时回滚就会失败.
这种情况下就需要管理员人为干预恢复过程然后让陈旧成员执行初始化同步.
为了避免回滚失败, 应该时刻保持副本集中 secondaries 的数据尽可能最新.
