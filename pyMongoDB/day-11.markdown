# MongoDB Day 11

<br>
<br>

## Replica Configuration

可以通过传给主数据库一个配置文档来配置一个副本集:

```js
config = {
    "_id" : "trial",
    "members" : [
        { "_id" : 0, "host" : "rs0:31000" },
        { "_id" : 1, "host" : "rs1:31001" },
        { "_id" : 2, "host" : "rs2:31002" }
    ]
}

// 这里 "_id" 字段即 replSet <name> 所指定的副本集名称, 二者要保持一致.
// "members" 则传入副本集的成员列表, 每个成员也要包含一个唯一标识字段 "_id".

// 连接至主数据库并传入配置文档
client = new Mongo("rs0:31000")
pdb = client.getDB("test")
pdb.initiate(config)
```

通常在部署 MongoDB 时, 哪怕目前只用到一个实例,
但为了方便扩展也可以将其部署为一个只有一个成员的副本集.
这样扩展规模时就不需要停机创建副本集而直接添加成员即可.

如果正在创建一个全新的副本集, 可以将配置文档传递给副本集的任意一个成员.
而如果副本集中有一个成员已经持有数据, 则必须将配置文档传递给这个成员.
如果已经持有数据的成员不止一个, 那么这个副本集就无法被初始化.

#### global variable "rs"

全局变量 `rs` 包含了一系列与 replication 相关的辅助函数,
可以使用 `rs.help()` 查看.

#### network

副本集内每个成员都必须能够连接到其它所有成员 (包括它自己).
在配置网络时应该避免使用 "localhost" 作为主机名.

#### modification

副本集的配置可以随时修改, 例如使用 `rs.add()` 添加节点, 或使用 `rs.remove()` 移除节点.

> 很多改变副本集配置的操作会返回一些无法连接数据库的错误信息,
> 这是因为主节点会暂时关闭所有连接以生效新配置.

完成修改后, 可以在 shell 中执行 `rs.config()` 来查看配置是否修改成功.
返回结果中的 "version" 字段会随着修改次数自增, 初始值为 1.
对于更加复杂的修改, 通常 `rs.reconfig()` 会更有效, 它可以接受所有合法的修改请求.

```js
conf = rs.config()
/* modify... */
rs.reconfig(conf)
```

#### purpose

副本集中一个很重要的概念是 "majority", 即在选举 "primary" 的过程中需要多数节点同意.
一个副本集中的 "majority" 是基于配置信息来计算的, 所以节点离线并不会影响这个值.

例如一个包含 5 个节点的副本集, 其中如果有 3 个成员离线, 则剩余 2 个节点已经不能构成多数,
它们无法完成投票过程. 如果这两个节点中有一个主节点,
它也将因为无法得到多数支持而变为备份节点.
于是最后这个副本集将持有 3 个不可用节点和 2 个备份节点.

这里还存在一个特殊情况就是, 如果由于某些特殊网络故障而导致 3 个离线节点之间网络是正常的,
则它们满足多数表决条件, 于是这三个节点中会产生新的主节点.

根据这样的多数表决机制, 通常在设计副本集时就会有意识的设计为几种模式
- 多数成员位于一个数据中心且主节点也位于该数据中心, 这样保证主数据中心正常运转时总有一个唯一的主节点.
可一旦主数据中心不可用, 这种部署策略也会导致备份数据中心的成员无法选举出新的主节点.
- 两个数据中心各自放置数量相等的成员, 在第三个额外位置部署用于决定选举的节点.
这样可以保障任意数据中心都可以通过这第三个节点来满足多数条件.

无论面对何种复杂的需求, 核心的设计原则就是考虑在出现意外情况时如何能够保障 "majority".

在进行选举时, 希望成为主节点的成员必须使用复制将自己的数据更新为最新状态,
副本集中其它成员会对此进行检查, 因为复制操作是严格按照时间排序的,
所以候选人的最后一条操作要比它能联通的其它节点更晚或至少相等.

<br>
<br>

## Member Configuration

#### Arbiter

所谓 "arbiter" 是一种特殊的副本集成员, 它唯一的作用就是参与选举用来保障多数条件成立.
如果可能, 应该将 arbiter 放在单独的故障域内与其它成员分开, 这样它就可以以 "外部视角"
来看待副本集中的成员了.

```js
// 使用 rs.addArb() 函数向副本集中添加 arbiter
rs.addArb("rs3:31003")
// 也可以使用 "arbiterOnly" 参数指定一个成员为 arbiter
rs.add({"_id": 3, "host": "rs3:31003", "arbiterOnly": true})
```

一旦某个成员以 arbiter 的身份被添加至副本集, 它就永远都只能是 arbiter, 这个过程不可逆.

通常 arbiter 只针对于偶数个节点的副本集使用. 如果节点数量是奇数个, 那么就不需要 arbiter.
一个 "多余" 的仲裁者并不能加快选举过程或提高数据安全性.
例如一个包含 3 个成员的副本集原本需要 2 个成员达到多数, 而当加入了一个 arbiter 后,
副本集中总共包含了 4 个成员, 需要 3 个成员才能达到多数.
因此该副本集的稳定性反而因为 arbiter 的加入而降低了.

基于 arbiter 的机制, 通常当我们不知道应该将一个成员划分为 arbiter 还是 secondary 时,
通常都会选择将其作为普通数据节点来使用. 尤其对于一些仅仅包含数个节点的小规模部署来说,
arbiter 往往会导致一些操作性的任务变困难. 所以应该尽量使用奇数个成员的副本集部署而避免使用 arbiter.

#### Priority

成员的优先级表现为一个成员在选举过程中成为 primary 的可能性. 取值范围为 `[0.0, 1000.0]` 之间的浮点数.
默认情况下优先级为 `1`. 而 `0` 作为一个特殊值, 优先级被赋值为 `0` 的成员永远不能够被选为 primary,
这样的节点包括 "hidden members", "delayed members", "arbiter".

```js
// copy replica set configuration to a variable
cfg = rs.conf()
// configure member's priority
cfg.members[0].priority = 0.5
cfg.members[1].priority = 1.5
cfg.memvers[2].priority = 2
cfg.add({"_id": 3, "host": "rs3:31003", "priority": 2.5})
// assign new configuration
rs.reconfig(cfg)
```

执行 `rs.reconfig(cfg)` 后当前主节点将离线应用新配置并导致一轮新的选举产生新的主节点.
拥有最高优先级的节点将会优先被选为主节点 (也要同时满足多数条件和节点数据最新).

需要注意因为修改副本集配置时, 新的配置必须要发送给在新配置下可能会成为主节点的成员.
因此无法在一次 `reconfig` 操作中将当前主节点的优先级设置为 `0`,
也不能对所有成员的优先级都为 `0` 的副本集进行 `reconfig`.

#### Hidden members

隐藏指的是客户端无法向其发送请求, 隐藏成员也不会作为复制源 (尽管当其它复制源不可用时隐藏成员也会被使用).
因此, 经常会将备份服务器或一些性能不佳的服务器隐藏起来.

```js
cfg = rs.conf()
cfg.members[0].priority = 0
cfg.members[0].hidden = true
rs.reconfig(cfg)
```

隐藏成员不会出现在 `rs.isMaster()` 返回的结果中, 但是依旧可以通过 `rs.status()` 和 `rs.config()` 发现.
取消一个成员的隐藏属性, 只需要更改 `hidden = true`.

#### Delayed members

数据可能会因为人为的错误而遭到破坏, 为了防止因为外界因素导致数据丢失, 可以通过 `slaveDelay` 设置一个延迟备份节点.
延迟备份节点的数据会比主节点延迟 `n` 秒, 当主节点数据丢失时, 可以通过延迟节点恢复.

```js
cfg = rs.conf()
cfg.members[0].priority = 0
cfg.members[0].hidden = true
cfg.members[0].slaveDelay = 3600
rs.reconfig(cfg)
```

因为延迟节点是不应该对应用做出任何响应的, 所以虽然不是必须的, 但还是大都会将其设为隐藏.

#### Non-voting members

"Non-voting" 即剥夺某节点的投票权利, 它存在的原因是因为 MongoDB 限制一个副本集中至多只能有 7 个成员参与投票,
如果超过这个数字则会导致 1 分钟内无法选出新的主节点. 可以通过设定 `votes` 参数为 `0` 来禁用投票.

```js
cfg = rs.conf()
cfg.members[3].votes = 0
cfg.members[4].votes = 0
cfg.members[5].votes = 0
rs.reconfig(cfg)
```

需要注意的是, 没有 "选举" 的权利并不代表没有 "当选" 的权利, Non-voting members 依旧可以被选为主节点.
通常来说, 如果可以的话, 尽量不应部署过度冗余的副本集.

#### indexes

备份节点并不需要与主节点持有相同的索引. 比如如果某个节点的用途仅仅是备份或离线的批量任务,
那么可以通过制定 `buildIndexes : false` 选项禁用索引. 但需要注意该选项是一个永久选项,
唯一恢复一个节点为普通成员的方法就是从副本集中删除它并删除所有数据, 然后重新加入副本集并复制数据.
此外, 这个选项还要求成员的优先级为 `0`.
