# MongoDB Day 4

<br>
<br>

## Index

数据库的索引就和书籍的目录类似, 让我们查询特定内容时不必翻完整本书.
不使用索引的查询称为 "Full table scan", 显然对于海量数据来说这种查询方式的效率非常低.

举例来说, 假设有集合 `library` 包含 `1,000,000` 个文档.
可以使用 `explain()` 函数查看 MongoDB 的查询过程.

```js
// query
db.books.find({"date": "cookbook"}).explain()

// result
{
    "cursor": "BasicCursor",
    "nscanned": 1000000,
    "nscannedObjects": 1000000,
    "n": 1,
    "millis": 721,
    // ...
}
```

- `nscanned` 表示 MongoDB 完成这个查询所扫描的文档数量, 可以看到该查询扫描了整个集合.
- `millis` 表示查询耗费的时间 (ms), 该查询消耗了 721 ms.
- `n` 表示匹配的结果数量. 因为不知道字段是否唯一, 所以 MongoDB 会查询所有的文档,
如果明确查询的是唯一字段, 则可以使用 `db.books.find({"date": "cookbook"}).limit(1)`
来限制结果数量, 这样就不会遍历后续的文档.

很显然, 限制查询结果数量并不是一个好方案, 它所受的限制太多, 只能在极为有限的场景中应用.
对于大多数场景, 索引会是一个很好的解决方案, 它会根据特定字段组织数据以加快查询过程.

```js
// create index
db.books.ensureIndex({"date": 1})
// query
db.books.find({"date": "cookbook"}).explain()

// result
{
    "cursor": "BtreeCursor date_1",
    "nscanned": 1,
    "nscannedObjects": 1,
    "n": 1,
    "millis": 3,
    // ...
}
```
通过索引, 可以看到再次查询的结果返回仅花了 3 ms, 且对于任意 `date` 键的查找这个时间基本是固定的.

视主机性能和集合大小不同, 创建索引的过程可能会需要一定时间,
如果 `ensureIndex` 长时间没有返回结果可以在另一个 shell 中执行 `db.currentOp()`
或者在日志中查看索引创建的进度.

然而使用索引也是有相应的代价的. 对于添加的每个索引, 每次的写操作都将耗费更多的时间.
因为当数据发生变动时, MongoDB 不仅要更新文档, 还要更新集合上的所有索引.
因此, MongoDB 限制每个集合上最多只能有 64 个索引. 而在实际使用中通常索引的数量不应该超过两个.
故而设计适当的索引字段是非常重要的.

通常来说可以从以往的查询记录筛选那些频繁的查询, 或者需要被优化的查询,
从中找出一组常用的键来建立索引.

<br>
<br>

## Compound Index

因为索引的值是按照一定顺序排列的, 因此使用索引键对文档进行排序是非常快的.
然而只有在首先使用索引键进行排序时它才会起作用.

```js
db.books.find().sort({"author": 1, "date": 1})
```

在上边这个例子中, 索引键 `date` 因为不是首选的排序项, 因而索引在该排序中发挥的作用不大.
要优化这个排序可以建立一个 `age` 和 `date` 的复合索引.

```js
db.books.ensureIndex({"author": 1, "date": 1})
```

如上, 所谓复合索引就是建立在多个键上的索引,
如果查询中有多个排序方向或者查询条件中有多个键, 复合索引就会非常有帮助.

#### 如何使用复合索引?

在很多查询中, 多个键的排序方向可能是不同的, 比如要按照 `author` 按字母序, `date` 由后往前排序.

```js
db.books.find().sort({"author": 1, "date": -1})
```

对于这个查询, 因为建立的索引为 `{"author": 1, "date": 1}`,
每一个 `author` 对应的 `date` 数据都是按照升序排序的,
该顺序对于 `"date": -1` 没有意义, 于是该查询将不再高效.

很自然地, 优化这个排序的方案就是建立对应的索引 `{"author": 1, "date": -1}`.
需要注意的就是两个相互反转的索引 (在每个排序方向上都 `* -1`) 是完全等价的,
即 `{"autho": 1, "date": -1}` 与 `{"author": -1, "date": 1}` 效果上完全相同.
也就是说, 索引的方向只针对于对多个键进行排序的场景,
如果只基于单一键排序, MongoDB 可以自动从相反的方向读取索引.

#### Covered Index

在实际的使用场景中, 我们更多情况下只需要查找索引中包含的字段而不需要获取文档本身.
所谓覆盖索引即当一个索引包含用户请求的所有字段, 可以认为这个索引覆盖了本次查询.

为了确保查询只使用索引就可以完成,
应该使用 `find()` 方法的第二个参数 `db.collection.find({<condition>}, {"_id": 0})`
来指定不要返回 `_id` 字段 (除非它是索引的一部分).

_覆盖索引无法作用于含有数组的字段上, 因为数组是被保存在索引中的._

#### Invisible Index

复合索引除了进行多键索引外, 另外一个功能就是可以对不同的查询表现为不同的索引.
举例来说比如 `ensureIndex({"author": 1, "date": -1})` 这个索引对
`find({"author": 1})` 这个查询来说, 就相当于存在一个 `{"author": 1}` 的索引.
因为当创建了这个复合索引的同时, `author` 字段就已经被排序了.

基于这个特性, 如果我们创建一个拥有 `n` 个键的复合索引,
那么就相当于获得了所有这 `n` 个键的 "前缀" 组成的索引.

```js
// 假设有这样一个包含 a-z 26 个键的索引
db.alph.ensureIndex({"a": 1, "b": 1, "c": 1, ..., "z": 1})

/*
于是就相当于拥有了以下索引

{"a": 1}
{"a": 1, "b": 1}
{"a": 1, "b": 1, "c": 1}
...
{"a": 1, "b": 1, "c": 1, ..., "z": 1}

但是由任意子集所组成的索引未必可用, 比如:

{"b": 1}
{"a": 1, "c": 1}
{"b": 1, "a": 1}

类似这样顺序打乱的索引在查询时是不会被优化的,
只有能够使用 "索引前缀" 的查询才会被优化
*/
```
